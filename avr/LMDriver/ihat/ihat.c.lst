
ihat.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000272  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000002a6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000002a6  2**0
                  ALLOC
  3 .debug_abbrev 000001aa  00000000  00000000  000002a6  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000675  00000000  00000000  00000450  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   0000034f  00000000  00000000  00000ac5  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .progmem.data 000001ef  00000000  00000000  00000e14  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .debug_frame  00000050  00000000  00000000  00001004  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_loc    0000035f  00000000  00000000  00001054  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 000000c7  00000000  00000000  000013b3  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_pubtypes 00000038  00000000  00000000  0000147a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_aranges 00000020  00000000  00000000  000014b2  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 12 .debug_str    000001fa  00000000  00000000  000014d2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <spiOut>:

// msb first, sck low on idle, sample on leading edge
void spiOut(unsigned char dataleft, unsigned char dataright)
{
    // set the SS lines
    PORTC &= ~LEFT_SS;
   0:	43 98       	cbi	0x08, 3	; 8
    PORTC &= ~RIGHT_SS;
   2:	45 98       	cbi	0x08, 5	; 8
   4:	98 e0       	ldi	r25, 0x08	; 8

    unsigned char ii;
    for (ii = 0; ii < 8; ii++)
    {
        if (dataright & 0x80) { PORTC |= RIGHT_MOSI; } 
   6:	67 ff       	sbrs	r22, 7
   8:	00 c0       	rjmp	.+0      	; 0xa <spiOut+0xa>
   a:	44 9a       	sbi	0x08, 4	; 8
   c:	00 c0       	rjmp	.+0      	; 0xe <spiOut+0xe>
        else { PORTC &= ~RIGHT_MOSI; }
   e:	44 98       	cbi	0x08, 4	; 8

        if (dataleft & 0x80) { PORTC |= LEFT_MOSI; } 
  10:	87 ff       	sbrs	r24, 7
  12:	00 c0       	rjmp	.+0      	; 0x14 <spiOut+0x14>
  14:	42 9a       	sbi	0x08, 2	; 8
  16:	00 c0       	rjmp	.+0      	; 0x18 <spiOut+0x18>
        else { PORTC &= ~LEFT_MOSI; }
  18:	42 98       	cbi	0x08, 2	; 8
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  1a:	25 ed       	ldi	r18, 0xD5	; 213
  1c:	2a 95       	dec	r18
  1e:	01 f4       	brne	.+0      	; 0x20 <spiOut+0x20>
  20:	00 00       	nop

        _delay_us(SPIBIT_DELAYUS);
        PORTC |= BOTH_SCK;
  22:	41 9a       	sbi	0x08, 1	; 8
  24:	25 ed       	ldi	r18, 0xD5	; 213
  26:	2a 95       	dec	r18
  28:	01 f4       	brne	.+0      	; 0x2a <spiOut+0x2a>
  2a:	00 00       	nop
        _delay_us(SPIBIT_DELAYUS);
        PORTC &= ~BOTH_SCK;
  2c:	41 98       	cbi	0x08, 1	; 8
  2e:	91 50       	subi	r25, 0x01	; 1
    // set the SS lines
    PORTC &= ~LEFT_SS;
    PORTC &= ~RIGHT_SS;

    unsigned char ii;
    for (ii = 0; ii < 8; ii++)
  30:	01 f0       	breq	.+0      	; 0x32 <spiOut+0x32>

        _delay_us(SPIBIT_DELAYUS);
        PORTC |= BOTH_SCK;
        _delay_us(SPIBIT_DELAYUS);
        PORTC &= ~BOTH_SCK;
        dataleft <<= 1;
  32:	88 0f       	add	r24, r24
        dataright <<= 1;
  34:	66 0f       	add	r22, r22
  36:	00 c0       	rjmp	.+0      	; 0x38 <spiOut+0x38>
    }
    // reset the SS lines
    PORTC |= LEFT_SS;
  38:	43 9a       	sbi	0x08, 3	; 8
    PORTC |= RIGHT_SS;
  3a:	45 9a       	sbi	0x08, 5	; 8
}
  3c:	08 95       	ret

0000003e <stringOut>:

void stringOut(unsigned char * stringPtr)
{
    unsigned char data = pgm_read_byte_near(stringPtr++);
  3e:	fc 01       	movw	r30, r24
  40:	84 91       	lpm	r24, Z+
    while (data)
  42:	81 11       	cpse	r24, r1
  44:	00 c0       	rjmp	.+0      	; 0x46 <stringOut+0x8>
  46:	08 95       	ret

00000048 <pickTransform>:
    //    _delay_ms(1);
    }
}

unsigned char pickTransform(int random, unsigned char ** ptr)
{
  48:	fb 01       	movw	r30, r22
    switch (random % 6)
  4a:	66 e0       	ldi	r22, 0x06	; 6
  4c:	70 e0       	ldi	r23, 0x00	; 0
  4e:	0e 94 00 00 	call	0	; 0x0 <spiOut>
  52:	82 30       	cpi	r24, 0x02	; 2
  54:	91 05       	cpc	r25, r1
  56:	01 f0       	breq	.+0      	; 0x58 <pickTransform+0x10>
  58:	83 30       	cpi	r24, 0x03	; 3
  5a:	91 05       	cpc	r25, r1
  5c:	04 f4       	brge	.+0      	; 0x5e <pickTransform+0x16>
  5e:	00 97       	sbiw	r24, 0x00	; 0
  60:	01 f0       	breq	.+0      	; 0x62 <pickTransform+0x1a>
  62:	81 30       	cpi	r24, 0x01	; 1
  64:	91 05       	cpc	r25, r1
  66:	01 f4       	brne	.+0      	; 0x68 <pickTransform+0x20>
  68:	00 c0       	rjmp	.+0      	; 0x6a <pickTransform+0x22>
  6a:	84 30       	cpi	r24, 0x04	; 4
  6c:	91 05       	cpc	r25, r1
  6e:	01 f0       	breq	.+0      	; 0x70 <pickTransform+0x28>
  70:	84 30       	cpi	r24, 0x04	; 4
  72:	91 05       	cpc	r25, r1
  74:	04 f0       	brlt	.+0      	; 0x76 <pickTransform+0x2e>
  76:	85 30       	cpi	r24, 0x05	; 5
  78:	91 05       	cpc	r25, r1
  7a:	01 f4       	brne	.+0      	; 0x7c <pickTransform+0x34>
  7c:	00 c0       	rjmp	.+0      	; 0x7e <pickTransform+0x36>
    {
        case 0: *ptr = txStrShiftUp; return sizeof(txStrShiftUp);
  7e:	80 e0       	ldi	r24, 0x00	; 0
  80:	90 e0       	ldi	r25, 0x00	; 0
  82:	00 c0       	rjmp	.+0      	; 0x84 <pickTransform+0x3c>
        case 1: *ptr = txStrShiftDown; return sizeof(txStrShiftDown);
  84:	80 e0       	ldi	r24, 0x00	; 0
  86:	90 e0       	ldi	r25, 0x00	; 0
  88:	00 c0       	rjmp	.+0      	; 0x8a <pickTransform+0x42>
        case 2: *ptr = txStrShiftLeft; return sizeof(txStrShiftLeft);
  8a:	80 e0       	ldi	r24, 0x00	; 0
  8c:	90 e0       	ldi	r25, 0x00	; 0
  8e:	00 c0       	rjmp	.+0      	; 0x90 <pickTransform+0x48>
        case 3: *ptr = txStrShiftRight; return sizeof(txStrShiftRight);
  90:	80 e0       	ldi	r24, 0x00	; 0
  92:	90 e0       	ldi	r25, 0x00	; 0
  94:	00 c0       	rjmp	.+0      	; 0x96 <pickTransform+0x4e>
        case 4: *ptr = txStrShiftLeftRight; return sizeof(txStrShiftLeftRight);
  96:	80 e0       	ldi	r24, 0x00	; 0
  98:	90 e0       	ldi	r25, 0x00	; 0
  9a:	91 83       	std	Z+1, r25	; 0x01
  9c:	80 83       	st	Z, r24
  9e:	89 e2       	ldi	r24, 0x29	; 41
  a0:	08 95       	ret
        case 5: *ptr = txStrShiftUpDown; return sizeof(txStrShiftUpDown);
  a2:	80 e0       	ldi	r24, 0x00	; 0
  a4:	90 e0       	ldi	r25, 0x00	; 0
  a6:	91 83       	std	Z+1, r25	; 0x01
  a8:	80 83       	st	Z, r24
  aa:	89 e3       	ldi	r24, 0x39	; 57
  ac:	08 95       	ret
    }
    return 0;
  ae:	80 e0       	ldi	r24, 0x00	; 0
}
  b0:	08 95       	ret

000000b2 <main>:


int main(void)
{
  b2:	4f 92       	push	r4
  b4:	5f 92       	push	r5
  b6:	6f 92       	push	r6
  b8:	7f 92       	push	r7
  ba:	8f 92       	push	r8
  bc:	9f 92       	push	r9
  be:	af 92       	push	r10
  c0:	bf 92       	push	r11
  c2:	cf 92       	push	r12
  c4:	df 92       	push	r13
  c6:	ef 92       	push	r14
  c8:	ff 92       	push	r15
  ca:	0f 93       	push	r16
  cc:	1f 93       	push	r17
  ce:	df 93       	push	r29
  d0:	cf 93       	push	r28
  d2:	00 d0       	rcall	.+0      	; 0xd4 <main+0x22>
  d4:	cd b7       	in	r28, 0x3d	; 61
  d6:	de b7       	in	r29, 0x3e	; 62
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  d8:	8f e1       	ldi	r24, 0x1F	; 31
  da:	9e e4       	ldi	r25, 0x4E	; 78
  dc:	01 97       	sbiw	r24, 0x01	; 1
  de:	01 f4       	brne	.+0      	; 0xe0 <main+0x2e>
  e0:	00 c0       	rjmp	.+0      	; 0xe2 <main+0x30>
  e2:	00 00       	nop
    unsigned long x = 0;
    // A little settling time...
    _delay_ms(10);
    // initialize
    DDRC = 0x3e; // 0011 1110  both ss,mosi,sck  
  e4:	8e e3       	ldi	r24, 0x3E	; 62
  e6:	87 b9       	out	0x07, r24	; 7
    PORTC = 0x28; // 0010 1000
  e8:	88 e2       	ldi	r24, 0x28	; 40
  ea:	88 b9       	out	0x08, r24	; 8

    spiOut('*', '*');
  ec:	8a e2       	ldi	r24, 0x2A	; 42
  ee:	6a e2       	ldi	r22, 0x2A	; 42
  f0:	0e 94 00 00 	call	0	; 0x0 <spiOut>
  f4:	8f ef       	ldi	r24, 0xFF	; 255
  f6:	90 e7       	ldi	r25, 0x70	; 112
  f8:	a2 e0       	ldi	r26, 0x02	; 2
  fa:	81 50       	subi	r24, 0x01	; 1
  fc:	90 40       	sbci	r25, 0x00	; 0
  fe:	a0 40       	sbci	r26, 0x00	; 0
 100:	01 f4       	brne	.+0      	; 0x102 <main+0x50>
 102:	00 c0       	rjmp	.+0      	; 0x104 <main+0x52>
 104:	00 00       	nop
    _delay_ms(100);
    spiOut('L', 'L');
 106:	8c e4       	ldi	r24, 0x4C	; 76
 108:	6c e4       	ldi	r22, 0x4C	; 76
 10a:	0e 94 00 00 	call	0	; 0x0 <spiOut>
    spiOut('0', '0');
 10e:	80 e3       	ldi	r24, 0x30	; 48
 110:	60 e3       	ldi	r22, 0x30	; 48
 112:	0e 94 00 00 	call	0	; 0x0 <spiOut>
    spiOut('1', '1');
 116:	81 e3       	ldi	r24, 0x31	; 49
 118:	61 e3       	ldi	r22, 0x31	; 49
 11a:	0e 94 00 00 	call	0	; 0x0 <spiOut>
    spiOut('l', 'l');
 11e:	8c e6       	ldi	r24, 0x6C	; 108
 120:	6c e6       	ldi	r22, 0x6C	; 108
 122:	0e 94 00 00 	call	0	; 0x0 <spiOut>
    spiOut('0', '0');
 126:	80 e3       	ldi	r24, 0x30	; 48
 128:	60 e3       	ldi	r22, 0x30	; 48
 12a:	0e 94 00 00 	call	0	; 0x0 <spiOut>
    spiOut('1', '1');
 12e:	81 e3       	ldi	r24, 0x31	; 49
 130:	61 e3       	ldi	r22, 0x31	; 49
 132:	0e 94 00 00 	call	0	; 0x0 <spiOut>
}


int main(void)
{
    unsigned long x = 0;
 136:	ee 24       	eor	r14, r14
 138:	ff 24       	eor	r15, r15
 13a:	87 01       	movw	r16, r14
    while (1)
    {
        // Pick a random message...
        unsigned char * ptr = text;
        x = x * 1664525L + 1013904223L;
        ptr += (x >> 17 & 0x7fff) % (sizeof(text)/4) * 4;
 13c:	52 e3       	ldi	r21, 0x32	; 50
 13e:	45 2e       	mov	r4, r21
 140:	51 2c       	mov	r5, r1
 142:	61 2c       	mov	r6, r1
 144:	71 2c       	mov	r7, r1

        // Pick a random transform...
        unsigned char ii;
        unsigned char jj;
        x = x * 1664525L + 1013904223L;
        ii = pickTransform(x >> 17 & 0x7fff, &ptr);
 146:	6e 01       	movw	r12, r28
 148:	08 94       	sec
 14a:	c1 1c       	adc	r12, r1
 14c:	d1 1c       	adc	r13, r1
    spiOut('1', '1');
    while (1)
    {
        // Pick a random message...
        unsigned char * ptr = text;
        x = x * 1664525L + 1013904223L;
 14e:	c8 01       	movw	r24, r16
 150:	b7 01       	movw	r22, r14
 152:	2d e0       	ldi	r18, 0x0D	; 13
 154:	36 e6       	ldi	r19, 0x66	; 102
 156:	49 e1       	ldi	r20, 0x19	; 25
 158:	50 e0       	ldi	r21, 0x00	; 0
 15a:	0e 94 00 00 	call	0	; 0x0 <spiOut>
 15e:	7b 01       	movw	r14, r22
 160:	8c 01       	movw	r16, r24
 162:	8f e5       	ldi	r24, 0x5F	; 95
 164:	93 ef       	ldi	r25, 0xF3	; 243
 166:	ae e6       	ldi	r26, 0x6E	; 110
 168:	bc e3       	ldi	r27, 0x3C	; 60
 16a:	e8 0e       	add	r14, r24
 16c:	f9 1e       	adc	r15, r25
 16e:	0a 1f       	adc	r16, r26
 170:	1b 1f       	adc	r17, r27
        ptr += (x >> 17 & 0x7fff) % (sizeof(text)/4) * 4;
 172:	c8 01       	movw	r24, r16
 174:	b7 01       	movw	r22, r14
 176:	41 e1       	ldi	r20, 0x11	; 17
 178:	96 95       	lsr	r25
 17a:	87 95       	ror	r24
 17c:	77 95       	ror	r23
 17e:	67 95       	ror	r22
 180:	4a 95       	dec	r20
 182:	01 f4       	brne	.+0      	; 0x184 <main+0xd2>
 184:	a3 01       	movw	r20, r6
 186:	92 01       	movw	r18, r4
 188:	0e 94 00 00 	call	0	; 0x0 <spiOut>
 18c:	fb 01       	movw	r30, r22
 18e:	ee 0f       	add	r30, r30
 190:	ff 1f       	adc	r31, r31
 192:	ee 0f       	add	r30, r30
 194:	ff 1f       	adc	r31, r31
 196:	e0 50       	subi	r30, 0x00	; 0
 198:	f0 40       	sbci	r31, 0x00	; 0
        
        unsigned char data1 = pgm_read_byte_near(ptr++);
 19a:	9f 01       	movw	r18, r30
 19c:	2f 5f       	subi	r18, 0xFF	; 255
 19e:	3f 4f       	sbci	r19, 0xFF	; 255
 1a0:	a4 90       	lpm	r10, Z+
        unsigned char data2 = pgm_read_byte_near(ptr++);
 1a2:	a9 01       	movw	r20, r18
 1a4:	4f 5f       	subi	r20, 0xFF	; 255
 1a6:	5f 4f       	sbci	r21, 0xFF	; 255
 1a8:	f9 01       	movw	r30, r18
 1aa:	b4 90       	lpm	r11, Z+
        unsigned char data3 = pgm_read_byte_near(ptr++);
 1ac:	9a 01       	movw	r18, r20
 1ae:	2f 5f       	subi	r18, 0xFF	; 255
 1b0:	3f 4f       	sbci	r19, 0xFF	; 255
 1b2:	fa 01       	movw	r30, r20
 1b4:	94 90       	lpm	r9, Z+
        unsigned char data4 = pgm_read_byte_near(ptr++);
 1b6:	d9 01       	movw	r26, r18
 1b8:	11 96       	adiw	r26, 0x01	; 1
 1ba:	ba 83       	std	Y+2, r27	; 0x02
 1bc:	a9 83       	std	Y+1, r26	; 0x01
 1be:	f9 01       	movw	r30, r18
 1c0:	84 90       	lpm	r8, Z+

        spiOut('a', 'a');
 1c2:	81 e6       	ldi	r24, 0x61	; 97
 1c4:	61 e6       	ldi	r22, 0x61	; 97
 1c6:	0e 94 00 00 	call	0	; 0x0 <spiOut>
        spiOut(data1, data3);
 1ca:	8a 2d       	mov	r24, r10
 1cc:	69 2d       	mov	r22, r9
 1ce:	0e 94 00 00 	call	0	; 0x0 <spiOut>
        spiOut('A', 'A');
 1d2:	81 e4       	ldi	r24, 0x41	; 65
 1d4:	61 e4       	ldi	r22, 0x41	; 65
 1d6:	0e 94 00 00 	call	0	; 0x0 <spiOut>
        spiOut(data2, data4);
 1da:	8b 2d       	mov	r24, r11
 1dc:	68 2d       	mov	r22, r8
 1de:	0e 94 00 00 	call	0	; 0x0 <spiOut>
 1e2:	8f ef       	ldi	r24, 0xFF	; 255
 1e4:	9d e3       	ldi	r25, 0x3D	; 61
 1e6:	a9 e4       	ldi	r26, 0x49	; 73
 1e8:	81 50       	subi	r24, 0x01	; 1
 1ea:	90 40       	sbci	r25, 0x00	; 0
 1ec:	a0 40       	sbci	r26, 0x00	; 0
 1ee:	01 f4       	brne	.+0      	; 0x1f0 <main+0x13e>
 1f0:	00 c0       	rjmp	.+0      	; 0x1f2 <main+0x140>
 1f2:	00 00       	nop
        _delay_ms(3000);

        // Pick a random transform...
        unsigned char ii;
        unsigned char jj;
        x = x * 1664525L + 1013904223L;
 1f4:	c8 01       	movw	r24, r16
 1f6:	b7 01       	movw	r22, r14
 1f8:	2d e0       	ldi	r18, 0x0D	; 13
 1fa:	36 e6       	ldi	r19, 0x66	; 102
 1fc:	49 e1       	ldi	r20, 0x19	; 25
 1fe:	50 e0       	ldi	r21, 0x00	; 0
 200:	0e 94 00 00 	call	0	; 0x0 <spiOut>
 204:	7b 01       	movw	r14, r22
 206:	8c 01       	movw	r16, r24
 208:	8f e5       	ldi	r24, 0x5F	; 95
 20a:	93 ef       	ldi	r25, 0xF3	; 243
 20c:	ae e6       	ldi	r26, 0x6E	; 110
 20e:	bc e3       	ldi	r27, 0x3C	; 60
 210:	e8 0e       	add	r14, r24
 212:	f9 1e       	adc	r15, r25
 214:	0a 1f       	adc	r16, r26
 216:	1b 1f       	adc	r17, r27
        ii = pickTransform(x >> 17 & 0x7fff, &ptr);
 218:	d8 01       	movw	r26, r16
 21a:	c7 01       	movw	r24, r14
 21c:	21 e1       	ldi	r18, 0x11	; 17
 21e:	b6 95       	lsr	r27
 220:	a7 95       	ror	r26
 222:	97 95       	ror	r25
 224:	87 95       	ror	r24
 226:	2a 95       	dec	r18
 228:	01 f4       	brne	.+0      	; 0x22a <main+0x178>
 22a:	b6 01       	movw	r22, r12
 22c:	0e 94 00 00 	call	0	; 0x0 <spiOut>
 230:	a8 2e       	mov	r10, r24

        for (jj = 0; jj < ii; jj++)
 232:	bb 24       	eor	r11, r11
 234:	00 c0       	rjmp	.+0      	; 0x236 <main+0x184>
        {
            data1 = pgm_read_byte_near(ptr++);
 236:	e9 81       	ldd	r30, Y+1	; 0x01
 238:	fa 81       	ldd	r31, Y+2	; 0x02
 23a:	9f 01       	movw	r18, r30
 23c:	2f 5f       	subi	r18, 0xFF	; 255
 23e:	3f 4f       	sbci	r19, 0xFF	; 255
 240:	3a 83       	std	Y+2, r19	; 0x02
 242:	29 83       	std	Y+1, r18	; 0x01
 244:	64 91       	lpm	r22, Z+
            spiOut(data1, data1);
 246:	86 2f       	mov	r24, r22
 248:	0e 94 00 00 	call	0	; 0x0 <spiOut>
 24c:	af e1       	ldi	r26, 0x1F	; 31
 24e:	be e4       	ldi	r27, 0x4E	; 78
 250:	11 97       	sbiw	r26, 0x01	; 1
 252:	01 f4       	brne	.+0      	; 0x254 <main+0x1a2>
 254:	00 c0       	rjmp	.+0      	; 0x256 <main+0x1a4>
 256:	00 00       	nop
        unsigned char ii;
        unsigned char jj;
        x = x * 1664525L + 1013904223L;
        ii = pickTransform(x >> 17 & 0x7fff, &ptr);

        for (jj = 0; jj < ii; jj++)
 258:	b3 94       	inc	r11
 25a:	ba 14       	cp	r11, r10
 25c:	00 f0       	brcs	.+0      	; 0x25e <main+0x1ac>
 25e:	8f ef       	ldi	r24, 0xFF	; 255
 260:	94 e3       	ldi	r25, 0x34	; 52
 262:	ac e0       	ldi	r26, 0x0C	; 12
 264:	81 50       	subi	r24, 0x01	; 1
 266:	90 40       	sbci	r25, 0x00	; 0
 268:	a0 40       	sbci	r26, 0x00	; 0
 26a:	01 f4       	brne	.+0      	; 0x26c <main+0x1ba>
 26c:	00 c0       	rjmp	.+0      	; 0x26e <main+0x1bc>
 26e:	00 00       	nop
            data1 = pgm_read_byte_near(ptr++);
            spiOut(data1, data1);
            _delay_ms(10);
        }
        _delay_ms(500);
    }
 270:	00 c0       	rjmp	.+0      	; 0x272 <txStrShiftLeftRight+0xac>
