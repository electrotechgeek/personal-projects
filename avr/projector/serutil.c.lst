
serutil.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001b0  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000001e4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000003  00000000  00000000  000001e4  2**0
                  ALLOC
  3 .stab         00000918  00000000  00000000  000001e4  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000b4f  00000000  00000000  00000afc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .progmem.data 00000010  00000000  00000000  0000164b  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
Disassembly of section .text:

00000000 <__vector_14>:
volatile u08 rxHead;
volatile u08 rxTail;

/* signal handler for tx complete interrupt */
ISR(USART0_UDRE_vect)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	8f 93       	push	r24
   c:	ef 93       	push	r30
   e:	ff 93       	push	r31
        if (uart_counter)
  10:	80 91 00 00 	lds	r24, 0x0000
  14:	88 23       	and	r24, r24
  16:	01 f0       	breq	.+0      	; 0x18 <__vector_14+0x18>
        {
                UDR = pgm_read_byte_near(uart_data_ptr);
  18:	e0 91 00 00 	lds	r30, 0x0000
  1c:	f0 91 00 00 	lds	r31, 0x0000
  20:	84 91       	lpm	r24, Z+
  22:	80 93 c6 00 	sts	0x00C6, r24
                uart_data_ptr++;
  26:	31 96       	adiw	r30, 0x01	; 1
  28:	f0 93 00 00 	sts	0x0000, r31
  2c:	e0 93 00 00 	sts	0x0000, r30
                uart_counter--;
  30:	80 91 00 00 	lds	r24, 0x0000
  34:	81 50       	subi	r24, 0x01	; 1
  36:	80 93 00 00 	sts	0x0000, r24
  3a:	00 c0       	rjmp	.+0      	; 0x3c <__vector_14+0x3c>
                return;
        }
        UCSRB &= ~_BV(UDRIE);
  3c:	80 91 c1 00 	lds	r24, 0x00C1
  40:	8f 7d       	andi	r24, 0xDF	; 223
  42:	80 93 c1 00 	sts	0x00C1, r24
}
  46:	ff 91       	pop	r31
  48:	ef 91       	pop	r30
  4a:	8f 91       	pop	r24
  4c:	0f 90       	pop	r0
  4e:	0f be       	out	0x3f, r0	; 63
  50:	0f 90       	pop	r0
  52:	1f 90       	pop	r1
  54:	18 95       	reti

00000056 <__vector_13>:

/* signal handler for rx complete interrupt */
ISR(USART0_RX_vect)
{
  56:	1f 92       	push	r1
  58:	0f 92       	push	r0
  5a:	0f b6       	in	r0, 0x3f	; 63
  5c:	0f 92       	push	r0
  5e:	11 24       	eor	r1, r1
  60:	8f 93       	push	r24
  62:	9f 93       	push	r25
  64:	ef 93       	push	r30
  66:	ff 93       	push	r31
    dataRxBuffer[rxTail++] = UDR;
  68:	80 91 00 00 	lds	r24, 0x0000
  6c:	90 91 c6 00 	lds	r25, 0x00C6
  70:	e0 e0       	ldi	r30, 0x00	; 0
  72:	f0 e0       	ldi	r31, 0x00	; 0
  74:	e8 0f       	add	r30, r24
  76:	f1 1d       	adc	r31, r1
  78:	90 83       	st	Z, r25
  7a:	8f 5f       	subi	r24, 0xFF	; 255
  7c:	80 93 00 00 	sts	0x0000, r24
    rxTail &= (RXBUFFERSIZE - 1);
  80:	80 91 00 00 	lds	r24, 0x0000
  84:	87 70       	andi	r24, 0x07	; 7
  86:	80 93 00 00 	sts	0x0000, r24
}
  8a:	ff 91       	pop	r31
  8c:	ef 91       	pop	r30
  8e:	9f 91       	pop	r25
  90:	8f 91       	pop	r24
  92:	0f 90       	pop	r0
  94:	0f be       	out	0x3f, r0	; 63
  96:	0f 90       	pop	r0
  98:	1f 90       	pop	r1
  9a:	18 95       	reti

0000009c <uart_get_buffered>:

u16 uart_get_buffered (void)
{
  u16 result = 0;

  if (rxTail != rxHead)
  9c:	90 91 00 00 	lds	r25, 0x0000
  a0:	80 91 00 00 	lds	r24, 0x0000
  a4:	98 17       	cp	r25, r24
  a6:	01 f4       	brne	.+0      	; 0xa8 <uart_get_buffered+0xc>
  a8:	20 e0       	ldi	r18, 0x00	; 0
  aa:	30 e0       	ldi	r19, 0x00	; 0
  ac:	00 c0       	rjmp	.+0      	; 0xae <uart_get_buffered+0x12>
    {
      cli();
  ae:	f8 94       	cli
      result = dataRxBuffer[rxHead++] | 0x0100;
  b0:	90 91 00 00 	lds	r25, 0x0000
  b4:	e9 2f       	mov	r30, r25
  b6:	f0 e0       	ldi	r31, 0x00	; 0
  b8:	e0 50       	subi	r30, 0x00	; 0
  ba:	f0 40       	sbci	r31, 0x00	; 0
  bc:	80 81       	ld	r24, Z
  be:	28 2f       	mov	r18, r24
  c0:	30 e0       	ldi	r19, 0x00	; 0
  c2:	31 60       	ori	r19, 0x01	; 1
  c4:	9f 5f       	subi	r25, 0xFF	; 255
  c6:	90 93 00 00 	sts	0x0000, r25
      rxHead &= (RXBUFFERSIZE - 1);
  ca:	80 91 00 00 	lds	r24, 0x0000
  ce:	87 70       	andi	r24, 0x07	; 7
  d0:	80 93 00 00 	sts	0x0000, r24
      sei();
  d4:	78 94       	sei
    }
  return result;
}
  d6:	c9 01       	movw	r24, r18
  d8:	08 95       	ret

000000da <uart_send_char>:

void uart_send_char (u08 character)
{
  da:	98 2f       	mov	r25, r24
  while (uart_counter);
  dc:	80 91 00 00 	lds	r24, 0x0000
  e0:	88 23       	and	r24, r24
  e2:	01 f4       	brne	.+0      	; 0xe4 <uart_send_char+0xa>
  loop_until_bit_is_set(UCSRA, UDRE);
  e4:	80 91 c0 00 	lds	r24, 0x00C0
  e8:	85 ff       	sbrs	r24, 5
  ea:	00 c0       	rjmp	.+0      	; 0xec <uart_send_char+0x12>
  UDR = character;
  ec:	90 93 c6 00 	sts	0x00C6, r25
}
  f0:	08 95       	ret

000000f2 <uart_send_async>:

void uart_send_async (u08 *buf, u08 size)
{
  f2:	9c 01       	movw	r18, r24
  while (uart_counter);
  f4:	80 91 00 00 	lds	r24, 0x0000
  f8:	88 23       	and	r24, r24
  fa:	01 f4       	brne	.+0      	; 0xfc <uart_send_async+0xa>
  loop_until_bit_is_set(UCSRA, UDRE);
  fc:	80 91 c0 00 	lds	r24, 0x00C0
 100:	85 ff       	sbrs	r24, 5
 102:	00 c0       	rjmp	.+0      	; 0x104 <uart_send_async+0x12>
  uart_counter = size;
 104:	60 93 00 00 	sts	0x0000, r22
  uart_data_ptr = buf;
 108:	30 93 00 00 	sts	0x0000, r19
 10c:	20 93 00 00 	sts	0x0000, r18
  UCSRB |= _BV(UDRIE);
 110:	80 91 c1 00 	lds	r24, 0x00C1
 114:	80 62       	ori	r24, 0x20	; 32
 116:	80 93 c1 00 	sts	0x00C1, r24
}
 11a:	08 95       	ret

0000011c <uart_send_sync>:

void uart_send_sync(u08 *buf, u08 size)
{ 
 11c:	fc 01       	movw	r30, r24
  while (uart_counter);
 11e:	80 91 00 00 	lds	r24, 0x0000
 122:	88 23       	and	r24, r24
 124:	01 f4       	brne	.+0      	; 0x126 <uart_send_sync+0xa>
  loop_until_bit_is_set(UCSRA, UDRE);
 126:	80 91 c0 00 	lds	r24, 0x00C0
 12a:	85 ff       	sbrs	r24, 5
 12c:	00 c0       	rjmp	.+0      	; 0x12e <uart_send_sync+0x12>
 12e:	00 c0       	rjmp	.+0      	; 0x130 <uart_send_sync+0x14>

  while (size)
    {
      loop_until_bit_is_set(UCSRA, UDRE);
 130:	80 91 c0 00 	lds	r24, 0x00C0
 134:	85 ff       	sbrs	r24, 5
 136:	00 c0       	rjmp	.+0      	; 0x138 <uart_send_sync+0x1c>
      UDR = pgm_read_byte_near(buf);
 138:	84 91       	lpm	r24, Z+
 13a:	80 93 c6 00 	sts	0x00C6, r24
      buf++;
 13e:	31 96       	adiw	r30, 0x01	; 1
      size--;
 140:	61 50       	subi	r22, 0x01	; 1
void uart_send_sync(u08 *buf, u08 size)
{ 
  while (uart_counter);
  loop_until_bit_is_set(UCSRA, UDRE);

  while (size)
 142:	66 23       	and	r22, r22
 144:	01 f4       	brne	.+0      	; 0x146 <uart_send_sync+0x2a>
      loop_until_bit_is_set(UCSRA, UDRE);
      UDR = pgm_read_byte_near(buf);
      buf++;
      size--;
    }
}
 146:	08 95       	ret

00000148 <uart_init>:
 
void uart_init(void)
{
  uart_counter = 0;
 148:	10 92 00 00 	sts	0x0000, r1
  rxHead = 0;
 14c:	10 92 00 00 	sts	0x0000, r1
  rxTail = 0;
 150:	10 92 00 00 	sts	0x0000, r1

  /* set baud rate */
  UBRR = UART_BAUD_SELECT;
 154:	8c e0       	ldi	r24, 0x0C	; 12
 156:	90 e0       	ldi	r25, 0x00	; 0
 158:	90 93 c5 00 	sts	0x00C5, r25
 15c:	80 93 c4 00 	sts	0x00C4, r24

  //  UCSRC = 0x0;
  UCSRB = _BV(RXCIE) | _BV(RXEN) | _BV(TXEN);
 160:	88 e9       	ldi	r24, 0x98	; 152
 162:	80 93 c1 00 	sts	0x00C1, r24
}
 166:	08 95       	ret

00000168 <uart_send_hex_byte>:

void uart_send_hex_byte(u08 byte)
{
 168:	28 2f       	mov	r18, r24
  uart_send_char(pgm_read_byte_near(hexTable + ((byte & 0xf0) >> 4)));
 16a:	e8 2f       	mov	r30, r24
 16c:	e2 95       	swap	r30
 16e:	ef 70       	andi	r30, 0x0F	; 15
 170:	f0 e0       	ldi	r31, 0x00	; 0
 172:	e0 50       	subi	r30, 0x00	; 0
 174:	f0 40       	sbci	r31, 0x00	; 0
 176:	94 91       	lpm	r25, Z+
  return result;
}

void uart_send_char (u08 character)
{
  while (uart_counter);
 178:	80 91 00 00 	lds	r24, 0x0000
 17c:	88 23       	and	r24, r24
 17e:	01 f4       	brne	.+0      	; 0x180 <uart_send_hex_byte+0x18>
  loop_until_bit_is_set(UCSRA, UDRE);
 180:	80 91 c0 00 	lds	r24, 0x00C0
 184:	85 ff       	sbrs	r24, 5
 186:	00 c0       	rjmp	.+0      	; 0x188 <uart_send_hex_byte+0x20>
  UDR = character;
 188:	90 93 c6 00 	sts	0x00C6, r25
}

void uart_send_hex_byte(u08 byte)
{
  uart_send_char(pgm_read_byte_near(hexTable + ((byte & 0xf0) >> 4)));
  uart_send_char(pgm_read_byte_near(hexTable + (byte & 0x0f)));
 18c:	e2 2f       	mov	r30, r18
 18e:	f0 e0       	ldi	r31, 0x00	; 0
 190:	ef 70       	andi	r30, 0x0F	; 15
 192:	f0 70       	andi	r31, 0x00	; 0
 194:	e0 50       	subi	r30, 0x00	; 0
 196:	f0 40       	sbci	r31, 0x00	; 0
 198:	e4 91       	lpm	r30, Z+
  return result;
}

void uart_send_char (u08 character)
{
  while (uart_counter);
 19a:	80 91 00 00 	lds	r24, 0x0000
 19e:	88 23       	and	r24, r24
 1a0:	01 f4       	brne	.+0      	; 0x1a2 <uart_send_hex_byte+0x3a>
  loop_until_bit_is_set(UCSRA, UDRE);
 1a2:	80 91 c0 00 	lds	r24, 0x00C0
 1a6:	85 ff       	sbrs	r24, 5
 1a8:	00 c0       	rjmp	.+0      	; 0x1aa <uart_send_hex_byte+0x42>
  UDR = character;
 1aa:	e0 93 c6 00 	sts	0x00C6, r30

void uart_send_hex_byte(u08 byte)
{
  uart_send_char(pgm_read_byte_near(hexTable + ((byte & 0xf0) >> 4)));
  uart_send_char(pgm_read_byte_near(hexTable + (byte & 0x0f)));
}
 1ae:	08 95       	ret
