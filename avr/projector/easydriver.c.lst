
easydriver.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000047a  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000004ae  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000004ae  2**0
                  ALLOC
  3 .stab         00000c18  00000000  00000000  000004b0  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000edf  00000000  00000000  000010c8  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <stepperInit>:
#define DRIVER_REVERSE PORTF &= ~_BV(3)


void stepperInit(void)
{
        DDRF = 0x18; // PF3,4
   0:	88 e1       	ldi	r24, 0x18	; 24
   2:	80 bb       	out	0x10, r24	; 16
        PORTF &= ~0x18; // set all bits low
   4:	81 b3       	in	r24, 0x11	; 17
   6:	87 7e       	andi	r24, 0xE7	; 231
   8:	81 bb       	out	0x11, r24	; 17
   a:	08 95       	ret

0000000c <stepper1Stop>:
        _delay_us(speed);
    }
}

void stepper1Stop(void)
{
   c:	08 95       	ret

0000000e <stepper1Forward>:
        DDRF = 0x18; // PF3,4
        PORTF &= ~0x18; // set all bits low
}

void stepper1Forward(unsigned char speed, unsigned int steps)
{
   e:	2f 92       	push	r2
  10:	3f 92       	push	r3
  12:	4f 92       	push	r4
  14:	5f 92       	push	r5
  16:	6f 92       	push	r6
  18:	7f 92       	push	r7
  1a:	8f 92       	push	r8
  1c:	9f 92       	push	r9
  1e:	af 92       	push	r10
  20:	bf 92       	push	r11
  22:	cf 92       	push	r12
  24:	df 92       	push	r13
  26:	ef 92       	push	r14
  28:	ff 92       	push	r15
  2a:	0f 93       	push	r16
  2c:	1f 93       	push	r17
  2e:	cf 93       	push	r28
  30:	df 93       	push	r29
  32:	cd b7       	in	r28, 0x3d	; 61
  34:	de b7       	in	r29, 0x3e	; 62
  36:	26 97       	sbiw	r28, 0x06	; 6
  38:	0f b6       	in	r0, 0x3f	; 63
  3a:	f8 94       	cli
  3c:	de bf       	out	0x3e, r29	; 62
  3e:	0f be       	out	0x3f, r0	; 63
  40:	cd bf       	out	0x3d, r28	; 61
  42:	7e 83       	std	Y+6, r23	; 0x06
  44:	6d 83       	std	Y+5, r22	; 0x05
    DRIVER_FORWARD;
  46:	8b 9a       	sbi	0x11, 3	; 17
    while (steps--)
    {
        DRIVER_STEP_ON;
        _delay_us(speed);
  48:	28 2f       	mov	r18, r24
  4a:	33 27       	eor	r19, r19
  4c:	44 27       	eor	r20, r20
  4e:	55 27       	eor	r21, r21
  50:	29 83       	std	Y+1, r18	; 0x01
  52:	3a 83       	std	Y+2, r19	; 0x02
  54:	4b 83       	std	Y+3, r20	; 0x03
  56:	5c 83       	std	Y+4, r21	; 0x04
  58:	00 c0       	rjmp	.+0      	; 0x5a <stepper1Forward+0x4c>
void stepper1Forward(unsigned char speed, unsigned int steps)
{
    DRIVER_FORWARD;
    while (steps--)
    {
        DRIVER_STEP_ON;
  5a:	8c 9a       	sbi	0x11, 4	; 17
        _delay_us(speed);
  5c:	69 81       	ldd	r22, Y+1	; 0x01
  5e:	7a 81       	ldd	r23, Y+2	; 0x02
  60:	8b 81       	ldd	r24, Y+3	; 0x03
  62:	9c 81       	ldd	r25, Y+4	; 0x04
  64:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
  68:	1b 01       	movw	r2, r22
  6a:	2c 01       	movw	r4, r24
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
  6c:	2b ea       	ldi	r18, 0xAB	; 171
  6e:	3a ea       	ldi	r19, 0xAA	; 170
  70:	4a e2       	ldi	r20, 0x2A	; 42
  72:	50 e4       	ldi	r21, 0x40	; 64
  74:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
  78:	5b 01       	movw	r10, r22
  7a:	6c 01       	movw	r12, r24
	if (__tmp < 1.0)
  7c:	20 e0       	ldi	r18, 0x00	; 0
  7e:	30 e0       	ldi	r19, 0x00	; 0
  80:	40 e8       	ldi	r20, 0x80	; 128
  82:	5f e3       	ldi	r21, 0x3F	; 63
  84:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
  88:	88 23       	and	r24, r24
  8a:	04 f4       	brge	.+0      	; 0x8c <stepper1Forward+0x7e>
  8c:	61 e0       	ldi	r22, 0x01	; 1
  8e:	00 c0       	rjmp	.+0      	; 0x90 <stepper1Forward+0x82>
		__ticks = 1;
	else if (__tmp > 255)
  90:	20 e0       	ldi	r18, 0x00	; 0
  92:	30 e0       	ldi	r19, 0x00	; 0
  94:	4f e7       	ldi	r20, 0x7F	; 127
  96:	53 e4       	ldi	r21, 0x43	; 67
  98:	c6 01       	movw	r24, r12
  9a:	b5 01       	movw	r22, r10
  9c:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
  a0:	18 16       	cp	r1, r24
  a2:	04 f0       	brlt	.+0      	; 0xa4 <stepper1Forward+0x96>
  a4:	00 c0       	rjmp	.+0      	; 0xa6 <stepper1Forward+0x98>
	{
		_delay_ms(__us / 1000.0);
  a6:	20 e0       	ldi	r18, 0x00	; 0
  a8:	30 e0       	ldi	r19, 0x00	; 0
  aa:	4a e7       	ldi	r20, 0x7A	; 122
  ac:	54 e4       	ldi	r21, 0x44	; 68
  ae:	c2 01       	movw	r24, r4
  b0:	b1 01       	movw	r22, r2
  b2:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
  b6:	3b 01       	movw	r6, r22
  b8:	4c 01       	movw	r8, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
  ba:	20 e0       	ldi	r18, 0x00	; 0
  bc:	30 e0       	ldi	r19, 0x00	; 0
  be:	4a ef       	ldi	r20, 0xFA	; 250
  c0:	54 e4       	ldi	r21, 0x44	; 68
  c2:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
  c6:	7b 01       	movw	r14, r22
  c8:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
  ca:	20 e0       	ldi	r18, 0x00	; 0
  cc:	30 e0       	ldi	r19, 0x00	; 0
  ce:	40 e8       	ldi	r20, 0x80	; 128
  d0:	5f e3       	ldi	r21, 0x3F	; 63
  d2:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
  d6:	88 23       	and	r24, r24
  d8:	04 f4       	brge	.+0      	; 0xda <stepper1Forward+0xcc>
  da:	81 e0       	ldi	r24, 0x01	; 1
  dc:	90 e0       	ldi	r25, 0x00	; 0
  de:	00 c0       	rjmp	.+0      	; 0xe0 <stepper1Forward+0xd2>
		__ticks = 1;
	else if (__tmp > 65535)
  e0:	20 e0       	ldi	r18, 0x00	; 0
  e2:	3f ef       	ldi	r19, 0xFF	; 255
  e4:	4f e7       	ldi	r20, 0x7F	; 127
  e6:	57 e4       	ldi	r21, 0x47	; 71
  e8:	c8 01       	movw	r24, r16
  ea:	b7 01       	movw	r22, r14
  ec:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
  f0:	18 16       	cp	r1, r24
  f2:	04 f4       	brge	.+0      	; 0xf4 <stepper1Forward+0xe6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
  f4:	20 e0       	ldi	r18, 0x00	; 0
  f6:	30 e0       	ldi	r19, 0x00	; 0
  f8:	40 e2       	ldi	r20, 0x20	; 32
  fa:	51 e4       	ldi	r21, 0x41	; 65
  fc:	c4 01       	movw	r24, r8
  fe:	b3 01       	movw	r22, r6
 100:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 104:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 108:	00 c0       	rjmp	.+0      	; 0x10a <stepper1Forward+0xfc>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 10a:	88 ec       	ldi	r24, 0xC8	; 200
 10c:	90 e0       	ldi	r25, 0x00	; 0
 10e:	01 97       	sbiw	r24, 0x01	; 1
 110:	01 f4       	brne	.+0      	; 0x112 <stepper1Forward+0x104>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 112:	61 50       	subi	r22, 0x01	; 1
 114:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 116:	61 15       	cp	r22, r1
 118:	71 05       	cpc	r23, r1
 11a:	01 f4       	brne	.+0      	; 0x11c <stepper1Forward+0x10e>
 11c:	00 c0       	rjmp	.+0      	; 0x11e <stepper1Forward+0x110>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
 11e:	c8 01       	movw	r24, r16
 120:	b7 01       	movw	r22, r14
 122:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 126:	cb 01       	movw	r24, r22
 128:	01 97       	sbiw	r24, 0x01	; 1
 12a:	01 f4       	brne	.+0      	; 0x12c <stepper1Forward+0x11e>
 12c:	00 c0       	rjmp	.+0      	; 0x12e <stepper1Forward+0x120>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
 12e:	c6 01       	movw	r24, r12
 130:	b5 01       	movw	r22, r10
 132:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 136:	6a 95       	dec	r22
 138:	01 f4       	brne	.+0      	; 0x13a <stepper1Forward+0x12c>
        DRIVER_STEP_OFF;
 13a:	8c 98       	cbi	0x11, 4	; 17
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
	if (__tmp < 1.0)
 13c:	20 e0       	ldi	r18, 0x00	; 0
 13e:	30 e0       	ldi	r19, 0x00	; 0
 140:	40 e8       	ldi	r20, 0x80	; 128
 142:	5f e3       	ldi	r21, 0x3F	; 63
 144:	c6 01       	movw	r24, r12
 146:	b5 01       	movw	r22, r10
 148:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 14c:	88 23       	and	r24, r24
 14e:	04 f4       	brge	.+0      	; 0x150 <stepper1Forward+0x142>
 150:	61 e0       	ldi	r22, 0x01	; 1
 152:	00 c0       	rjmp	.+0      	; 0x154 <stepper1Forward+0x146>
		__ticks = 1;
	else if (__tmp > 255)
 154:	20 e0       	ldi	r18, 0x00	; 0
 156:	30 e0       	ldi	r19, 0x00	; 0
 158:	4f e7       	ldi	r20, 0x7F	; 127
 15a:	53 e4       	ldi	r21, 0x43	; 67
 15c:	c6 01       	movw	r24, r12
 15e:	b5 01       	movw	r22, r10
 160:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 164:	18 16       	cp	r1, r24
 166:	04 f0       	brlt	.+0      	; 0x168 <stepper1Forward+0x15a>
 168:	00 c0       	rjmp	.+0      	; 0x16a <stepper1Forward+0x15c>
	{
		_delay_ms(__us / 1000.0);
 16a:	20 e0       	ldi	r18, 0x00	; 0
 16c:	30 e0       	ldi	r19, 0x00	; 0
 16e:	4a e7       	ldi	r20, 0x7A	; 122
 170:	54 e4       	ldi	r21, 0x44	; 68
 172:	c2 01       	movw	r24, r4
 174:	b1 01       	movw	r22, r2
 176:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 17a:	5b 01       	movw	r10, r22
 17c:	6c 01       	movw	r12, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
 17e:	20 e0       	ldi	r18, 0x00	; 0
 180:	30 e0       	ldi	r19, 0x00	; 0
 182:	4a ef       	ldi	r20, 0xFA	; 250
 184:	54 e4       	ldi	r21, 0x44	; 68
 186:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 18a:	7b 01       	movw	r14, r22
 18c:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
 18e:	20 e0       	ldi	r18, 0x00	; 0
 190:	30 e0       	ldi	r19, 0x00	; 0
 192:	40 e8       	ldi	r20, 0x80	; 128
 194:	5f e3       	ldi	r21, 0x3F	; 63
 196:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 19a:	88 23       	and	r24, r24
 19c:	04 f4       	brge	.+0      	; 0x19e <stepper1Forward+0x190>
 19e:	81 e0       	ldi	r24, 0x01	; 1
 1a0:	90 e0       	ldi	r25, 0x00	; 0
 1a2:	00 c0       	rjmp	.+0      	; 0x1a4 <stepper1Forward+0x196>
		__ticks = 1;
	else if (__tmp > 65535)
 1a4:	20 e0       	ldi	r18, 0x00	; 0
 1a6:	3f ef       	ldi	r19, 0xFF	; 255
 1a8:	4f e7       	ldi	r20, 0x7F	; 127
 1aa:	57 e4       	ldi	r21, 0x47	; 71
 1ac:	c8 01       	movw	r24, r16
 1ae:	b7 01       	movw	r22, r14
 1b0:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 1b4:	18 16       	cp	r1, r24
 1b6:	04 f4       	brge	.+0      	; 0x1b8 <stepper1Forward+0x1aa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
 1b8:	20 e0       	ldi	r18, 0x00	; 0
 1ba:	30 e0       	ldi	r19, 0x00	; 0
 1bc:	40 e2       	ldi	r20, 0x20	; 32
 1be:	51 e4       	ldi	r21, 0x41	; 65
 1c0:	c6 01       	movw	r24, r12
 1c2:	b5 01       	movw	r22, r10
 1c4:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 1c8:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 1cc:	00 c0       	rjmp	.+0      	; 0x1ce <stepper1Forward+0x1c0>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 1ce:	88 ec       	ldi	r24, 0xC8	; 200
 1d0:	90 e0       	ldi	r25, 0x00	; 0
 1d2:	01 97       	sbiw	r24, 0x01	; 1
 1d4:	01 f4       	brne	.+0      	; 0x1d6 <stepper1Forward+0x1c8>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 1d6:	61 50       	subi	r22, 0x01	; 1
 1d8:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 1da:	61 15       	cp	r22, r1
 1dc:	71 05       	cpc	r23, r1
 1de:	01 f4       	brne	.+0      	; 0x1e0 <stepper1Forward+0x1d2>
 1e0:	00 c0       	rjmp	.+0      	; 0x1e2 <stepper1Forward+0x1d4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
 1e2:	c8 01       	movw	r24, r16
 1e4:	b7 01       	movw	r22, r14
 1e6:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 1ea:	cb 01       	movw	r24, r22
 1ec:	01 97       	sbiw	r24, 0x01	; 1
 1ee:	01 f4       	brne	.+0      	; 0x1f0 <stepper1Forward+0x1e2>
 1f0:	00 c0       	rjmp	.+0      	; 0x1f2 <stepper1Forward+0x1e4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
 1f2:	c6 01       	movw	r24, r12
 1f4:	b5 01       	movw	r22, r10
 1f6:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 1fa:	6a 95       	dec	r22
 1fc:	01 f4       	brne	.+0      	; 0x1fe <stepper1Forward+0x1f0>
}

void stepper1Forward(unsigned char speed, unsigned int steps)
{
    DRIVER_FORWARD;
    while (steps--)
 1fe:	4d 81       	ldd	r20, Y+5	; 0x05
 200:	5e 81       	ldd	r21, Y+6	; 0x06
 202:	41 50       	subi	r20, 0x01	; 1
 204:	50 40       	sbci	r21, 0x00	; 0
 206:	5e 83       	std	Y+6, r21	; 0x06
 208:	4d 83       	std	Y+5, r20	; 0x05
 20a:	4f 5f       	subi	r20, 0xFF	; 255
 20c:	5f 4f       	sbci	r21, 0xFF	; 255
 20e:	01 f0       	breq	.+0      	; 0x210 <stepper1Forward+0x202>
 210:	00 c0       	rjmp	.+0      	; 0x212 <stepper1Forward+0x204>
 212:	26 96       	adiw	r28, 0x06	; 6
 214:	0f b6       	in	r0, 0x3f	; 63
 216:	f8 94       	cli
 218:	de bf       	out	0x3e, r29	; 62
 21a:	0f be       	out	0x3f, r0	; 63
 21c:	cd bf       	out	0x3d, r28	; 61
 21e:	df 91       	pop	r29
 220:	cf 91       	pop	r28
 222:	1f 91       	pop	r17
 224:	0f 91       	pop	r16
 226:	ff 90       	pop	r15
 228:	ef 90       	pop	r14
 22a:	df 90       	pop	r13
 22c:	cf 90       	pop	r12
 22e:	bf 90       	pop	r11
 230:	af 90       	pop	r10
 232:	9f 90       	pop	r9
 234:	8f 90       	pop	r8
 236:	7f 90       	pop	r7
 238:	6f 90       	pop	r6
 23a:	5f 90       	pop	r5
 23c:	4f 90       	pop	r4
 23e:	3f 90       	pop	r3
 240:	2f 90       	pop	r2
 242:	08 95       	ret

00000244 <stepper1Back>:
        _delay_us(speed);
    }
}

void stepper1Back(unsigned char speed, unsigned int steps)
{
 244:	2f 92       	push	r2
 246:	3f 92       	push	r3
 248:	4f 92       	push	r4
 24a:	5f 92       	push	r5
 24c:	6f 92       	push	r6
 24e:	7f 92       	push	r7
 250:	8f 92       	push	r8
 252:	9f 92       	push	r9
 254:	af 92       	push	r10
 256:	bf 92       	push	r11
 258:	cf 92       	push	r12
 25a:	df 92       	push	r13
 25c:	ef 92       	push	r14
 25e:	ff 92       	push	r15
 260:	0f 93       	push	r16
 262:	1f 93       	push	r17
 264:	cf 93       	push	r28
 266:	df 93       	push	r29
 268:	cd b7       	in	r28, 0x3d	; 61
 26a:	de b7       	in	r29, 0x3e	; 62
 26c:	26 97       	sbiw	r28, 0x06	; 6
 26e:	0f b6       	in	r0, 0x3f	; 63
 270:	f8 94       	cli
 272:	de bf       	out	0x3e, r29	; 62
 274:	0f be       	out	0x3f, r0	; 63
 276:	cd bf       	out	0x3d, r28	; 61
 278:	7e 83       	std	Y+6, r23	; 0x06
 27a:	6d 83       	std	Y+5, r22	; 0x05
    DRIVER_REVERSE;
 27c:	8b 98       	cbi	0x11, 3	; 17
    while (steps--)
    {
        DRIVER_STEP_ON;
        _delay_us(speed);
 27e:	28 2f       	mov	r18, r24
 280:	33 27       	eor	r19, r19
 282:	44 27       	eor	r20, r20
 284:	55 27       	eor	r21, r21
 286:	29 83       	std	Y+1, r18	; 0x01
 288:	3a 83       	std	Y+2, r19	; 0x02
 28a:	4b 83       	std	Y+3, r20	; 0x03
 28c:	5c 83       	std	Y+4, r21	; 0x04
 28e:	00 c0       	rjmp	.+0      	; 0x290 <stepper1Back+0x4c>
void stepper1Back(unsigned char speed, unsigned int steps)
{
    DRIVER_REVERSE;
    while (steps--)
    {
        DRIVER_STEP_ON;
 290:	8c 9a       	sbi	0x11, 4	; 17
        _delay_us(speed);
 292:	69 81       	ldd	r22, Y+1	; 0x01
 294:	7a 81       	ldd	r23, Y+2	; 0x02
 296:	8b 81       	ldd	r24, Y+3	; 0x03
 298:	9c 81       	ldd	r25, Y+4	; 0x04
 29a:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 29e:	1b 01       	movw	r2, r22
 2a0:	2c 01       	movw	r4, r24
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
 2a2:	2b ea       	ldi	r18, 0xAB	; 171
 2a4:	3a ea       	ldi	r19, 0xAA	; 170
 2a6:	4a e2       	ldi	r20, 0x2A	; 42
 2a8:	50 e4       	ldi	r21, 0x40	; 64
 2aa:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 2ae:	5b 01       	movw	r10, r22
 2b0:	6c 01       	movw	r12, r24
	if (__tmp < 1.0)
 2b2:	20 e0       	ldi	r18, 0x00	; 0
 2b4:	30 e0       	ldi	r19, 0x00	; 0
 2b6:	40 e8       	ldi	r20, 0x80	; 128
 2b8:	5f e3       	ldi	r21, 0x3F	; 63
 2ba:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 2be:	88 23       	and	r24, r24
 2c0:	04 f4       	brge	.+0      	; 0x2c2 <stepper1Back+0x7e>
 2c2:	61 e0       	ldi	r22, 0x01	; 1
 2c4:	00 c0       	rjmp	.+0      	; 0x2c6 <stepper1Back+0x82>
		__ticks = 1;
	else if (__tmp > 255)
 2c6:	20 e0       	ldi	r18, 0x00	; 0
 2c8:	30 e0       	ldi	r19, 0x00	; 0
 2ca:	4f e7       	ldi	r20, 0x7F	; 127
 2cc:	53 e4       	ldi	r21, 0x43	; 67
 2ce:	c6 01       	movw	r24, r12
 2d0:	b5 01       	movw	r22, r10
 2d2:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 2d6:	18 16       	cp	r1, r24
 2d8:	04 f0       	brlt	.+0      	; 0x2da <stepper1Back+0x96>
 2da:	00 c0       	rjmp	.+0      	; 0x2dc <stepper1Back+0x98>
	{
		_delay_ms(__us / 1000.0);
 2dc:	20 e0       	ldi	r18, 0x00	; 0
 2de:	30 e0       	ldi	r19, 0x00	; 0
 2e0:	4a e7       	ldi	r20, 0x7A	; 122
 2e2:	54 e4       	ldi	r21, 0x44	; 68
 2e4:	c2 01       	movw	r24, r4
 2e6:	b1 01       	movw	r22, r2
 2e8:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 2ec:	3b 01       	movw	r6, r22
 2ee:	4c 01       	movw	r8, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
 2f0:	20 e0       	ldi	r18, 0x00	; 0
 2f2:	30 e0       	ldi	r19, 0x00	; 0
 2f4:	4a ef       	ldi	r20, 0xFA	; 250
 2f6:	54 e4       	ldi	r21, 0x44	; 68
 2f8:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 2fc:	7b 01       	movw	r14, r22
 2fe:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
 300:	20 e0       	ldi	r18, 0x00	; 0
 302:	30 e0       	ldi	r19, 0x00	; 0
 304:	40 e8       	ldi	r20, 0x80	; 128
 306:	5f e3       	ldi	r21, 0x3F	; 63
 308:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 30c:	88 23       	and	r24, r24
 30e:	04 f4       	brge	.+0      	; 0x310 <stepper1Back+0xcc>
 310:	81 e0       	ldi	r24, 0x01	; 1
 312:	90 e0       	ldi	r25, 0x00	; 0
 314:	00 c0       	rjmp	.+0      	; 0x316 <stepper1Back+0xd2>
		__ticks = 1;
	else if (__tmp > 65535)
 316:	20 e0       	ldi	r18, 0x00	; 0
 318:	3f ef       	ldi	r19, 0xFF	; 255
 31a:	4f e7       	ldi	r20, 0x7F	; 127
 31c:	57 e4       	ldi	r21, 0x47	; 71
 31e:	c8 01       	movw	r24, r16
 320:	b7 01       	movw	r22, r14
 322:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 326:	18 16       	cp	r1, r24
 328:	04 f4       	brge	.+0      	; 0x32a <stepper1Back+0xe6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
 32a:	20 e0       	ldi	r18, 0x00	; 0
 32c:	30 e0       	ldi	r19, 0x00	; 0
 32e:	40 e2       	ldi	r20, 0x20	; 32
 330:	51 e4       	ldi	r21, 0x41	; 65
 332:	c4 01       	movw	r24, r8
 334:	b3 01       	movw	r22, r6
 336:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 33a:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 33e:	00 c0       	rjmp	.+0      	; 0x340 <stepper1Back+0xfc>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 340:	88 ec       	ldi	r24, 0xC8	; 200
 342:	90 e0       	ldi	r25, 0x00	; 0
 344:	01 97       	sbiw	r24, 0x01	; 1
 346:	01 f4       	brne	.+0      	; 0x348 <stepper1Back+0x104>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 348:	61 50       	subi	r22, 0x01	; 1
 34a:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 34c:	61 15       	cp	r22, r1
 34e:	71 05       	cpc	r23, r1
 350:	01 f4       	brne	.+0      	; 0x352 <stepper1Back+0x10e>
 352:	00 c0       	rjmp	.+0      	; 0x354 <stepper1Back+0x110>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
 354:	c8 01       	movw	r24, r16
 356:	b7 01       	movw	r22, r14
 358:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 35c:	cb 01       	movw	r24, r22
 35e:	01 97       	sbiw	r24, 0x01	; 1
 360:	01 f4       	brne	.+0      	; 0x362 <stepper1Back+0x11e>
 362:	00 c0       	rjmp	.+0      	; 0x364 <stepper1Back+0x120>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
 364:	c6 01       	movw	r24, r12
 366:	b5 01       	movw	r22, r10
 368:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 36c:	6a 95       	dec	r22
 36e:	01 f4       	brne	.+0      	; 0x370 <stepper1Back+0x12c>
        DRIVER_STEP_OFF;
 370:	8c 98       	cbi	0x11, 4	; 17
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
	if (__tmp < 1.0)
 372:	20 e0       	ldi	r18, 0x00	; 0
 374:	30 e0       	ldi	r19, 0x00	; 0
 376:	40 e8       	ldi	r20, 0x80	; 128
 378:	5f e3       	ldi	r21, 0x3F	; 63
 37a:	c6 01       	movw	r24, r12
 37c:	b5 01       	movw	r22, r10
 37e:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 382:	88 23       	and	r24, r24
 384:	04 f4       	brge	.+0      	; 0x386 <stepper1Back+0x142>
 386:	61 e0       	ldi	r22, 0x01	; 1
 388:	00 c0       	rjmp	.+0      	; 0x38a <stepper1Back+0x146>
		__ticks = 1;
	else if (__tmp > 255)
 38a:	20 e0       	ldi	r18, 0x00	; 0
 38c:	30 e0       	ldi	r19, 0x00	; 0
 38e:	4f e7       	ldi	r20, 0x7F	; 127
 390:	53 e4       	ldi	r21, 0x43	; 67
 392:	c6 01       	movw	r24, r12
 394:	b5 01       	movw	r22, r10
 396:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 39a:	18 16       	cp	r1, r24
 39c:	04 f0       	brlt	.+0      	; 0x39e <stepper1Back+0x15a>
 39e:	00 c0       	rjmp	.+0      	; 0x3a0 <stepper1Back+0x15c>
	{
		_delay_ms(__us / 1000.0);
 3a0:	20 e0       	ldi	r18, 0x00	; 0
 3a2:	30 e0       	ldi	r19, 0x00	; 0
 3a4:	4a e7       	ldi	r20, 0x7A	; 122
 3a6:	54 e4       	ldi	r21, 0x44	; 68
 3a8:	c2 01       	movw	r24, r4
 3aa:	b1 01       	movw	r22, r2
 3ac:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 3b0:	5b 01       	movw	r10, r22
 3b2:	6c 01       	movw	r12, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
 3b4:	20 e0       	ldi	r18, 0x00	; 0
 3b6:	30 e0       	ldi	r19, 0x00	; 0
 3b8:	4a ef       	ldi	r20, 0xFA	; 250
 3ba:	54 e4       	ldi	r21, 0x44	; 68
 3bc:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 3c0:	7b 01       	movw	r14, r22
 3c2:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
 3c4:	20 e0       	ldi	r18, 0x00	; 0
 3c6:	30 e0       	ldi	r19, 0x00	; 0
 3c8:	40 e8       	ldi	r20, 0x80	; 128
 3ca:	5f e3       	ldi	r21, 0x3F	; 63
 3cc:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 3d0:	88 23       	and	r24, r24
 3d2:	04 f4       	brge	.+0      	; 0x3d4 <stepper1Back+0x190>
 3d4:	81 e0       	ldi	r24, 0x01	; 1
 3d6:	90 e0       	ldi	r25, 0x00	; 0
 3d8:	00 c0       	rjmp	.+0      	; 0x3da <stepper1Back+0x196>
		__ticks = 1;
	else if (__tmp > 65535)
 3da:	20 e0       	ldi	r18, 0x00	; 0
 3dc:	3f ef       	ldi	r19, 0xFF	; 255
 3de:	4f e7       	ldi	r20, 0x7F	; 127
 3e0:	57 e4       	ldi	r21, 0x47	; 71
 3e2:	c8 01       	movw	r24, r16
 3e4:	b7 01       	movw	r22, r14
 3e6:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 3ea:	18 16       	cp	r1, r24
 3ec:	04 f4       	brge	.+0      	; 0x3ee <stepper1Back+0x1aa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
 3ee:	20 e0       	ldi	r18, 0x00	; 0
 3f0:	30 e0       	ldi	r19, 0x00	; 0
 3f2:	40 e2       	ldi	r20, 0x20	; 32
 3f4:	51 e4       	ldi	r21, 0x41	; 65
 3f6:	c6 01       	movw	r24, r12
 3f8:	b5 01       	movw	r22, r10
 3fa:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 3fe:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 402:	00 c0       	rjmp	.+0      	; 0x404 <stepper1Back+0x1c0>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 404:	88 ec       	ldi	r24, 0xC8	; 200
 406:	90 e0       	ldi	r25, 0x00	; 0
 408:	01 97       	sbiw	r24, 0x01	; 1
 40a:	01 f4       	brne	.+0      	; 0x40c <stepper1Back+0x1c8>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 40c:	61 50       	subi	r22, 0x01	; 1
 40e:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 410:	61 15       	cp	r22, r1
 412:	71 05       	cpc	r23, r1
 414:	01 f4       	brne	.+0      	; 0x416 <stepper1Back+0x1d2>
 416:	00 c0       	rjmp	.+0      	; 0x418 <stepper1Back+0x1d4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
 418:	c8 01       	movw	r24, r16
 41a:	b7 01       	movw	r22, r14
 41c:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
 420:	cb 01       	movw	r24, r22
 422:	01 97       	sbiw	r24, 0x01	; 1
 424:	01 f4       	brne	.+0      	; 0x426 <stepper1Back+0x1e2>
 426:	00 c0       	rjmp	.+0      	; 0x428 <stepper1Back+0x1e4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
 428:	c6 01       	movw	r24, r12
 42a:	b5 01       	movw	r22, r10
 42c:	0e 94 00 00 	call	0	; 0x0 <stepperInit>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 430:	6a 95       	dec	r22
 432:	01 f4       	brne	.+0      	; 0x434 <stepper1Back+0x1f0>
}

void stepper1Back(unsigned char speed, unsigned int steps)
{
    DRIVER_REVERSE;
    while (steps--)
 434:	4d 81       	ldd	r20, Y+5	; 0x05
 436:	5e 81       	ldd	r21, Y+6	; 0x06
 438:	41 50       	subi	r20, 0x01	; 1
 43a:	50 40       	sbci	r21, 0x00	; 0
 43c:	5e 83       	std	Y+6, r21	; 0x06
 43e:	4d 83       	std	Y+5, r20	; 0x05
 440:	4f 5f       	subi	r20, 0xFF	; 255
 442:	5f 4f       	sbci	r21, 0xFF	; 255
 444:	01 f0       	breq	.+0      	; 0x446 <stepper1Back+0x202>
 446:	00 c0       	rjmp	.+0      	; 0x448 <stepper1Back+0x204>
 448:	26 96       	adiw	r28, 0x06	; 6
 44a:	0f b6       	in	r0, 0x3f	; 63
 44c:	f8 94       	cli
 44e:	de bf       	out	0x3e, r29	; 62
 450:	0f be       	out	0x3f, r0	; 63
 452:	cd bf       	out	0x3d, r28	; 61
 454:	df 91       	pop	r29
 456:	cf 91       	pop	r28
 458:	1f 91       	pop	r17
 45a:	0f 91       	pop	r16
 45c:	ff 90       	pop	r15
 45e:	ef 90       	pop	r14
 460:	df 90       	pop	r13
 462:	cf 90       	pop	r12
 464:	bf 90       	pop	r11
 466:	af 90       	pop	r10
 468:	9f 90       	pop	r9
 46a:	8f 90       	pop	r8
 46c:	7f 90       	pop	r7
 46e:	6f 90       	pop	r6
 470:	5f 90       	pop	r5
 472:	4f 90       	pop	r4
 474:	3f 90       	pop	r3
 476:	2f 90       	pop	r2
 478:	08 95       	ret
