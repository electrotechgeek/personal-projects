
main.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000002f2  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000326  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000326  2**0
                  ALLOC
  3 .stab         00000930  00000000  00000000  00000328  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000cca  00000000  00000000  00000c58  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .progmem.data 000000aa  00000000  00000000  00001922  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
Disassembly of section .text:

00000000 <main>:
"cC: camera shutter (100ms pulse)\r\n"
"l : lamp on\r\n"
"L : lamp off\r\n";

int main(void)
{
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3
   4:	4f 92       	push	r4
   6:	5f 92       	push	r5
   8:	7f 92       	push	r7
   a:	8f 92       	push	r8
   c:	9f 92       	push	r9
   e:	af 92       	push	r10
  10:	bf 92       	push	r11
  12:	cf 92       	push	r12
  14:	df 92       	push	r13
  16:	ef 92       	push	r14
  18:	ff 92       	push	r15
  1a:	0f 93       	push	r16
  1c:	1f 93       	push	r17
  1e:	df 93       	push	r29
  20:	cf 93       	push	r28
  22:	00 d0       	rcall	.+0      	; 0x24 <main+0x24>
  24:	0f 92       	push	r0
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
        lcdInit();
  2a:	0e 94 00 00 	call	0	; 0x0 <main>
        lcdStringPtr(msgInit);
  2e:	80 e0       	ldi	r24, 0x00	; 0
  30:	90 e0       	ldi	r25, 0x00	; 0
  32:	0e 94 00 00 	call	0	; 0x0 <main>
        uart_init();
  36:	0e 94 00 00 	call	0	; 0x0 <main>
	uart_send_sync(msgInit, sizeof(msgInit));
  3a:	80 e0       	ldi	r24, 0x00	; 0
  3c:	90 e0       	ldi	r25, 0x00	; 0
  3e:	67 e0       	ldi	r22, 0x07	; 7
  40:	0e 94 00 00 	call	0	; 0x0 <main>
	uart_send_sync(helpMsg, sizeof(helpMsg));
  44:	80 e0       	ldi	r24, 0x00	; 0
  46:	90 e0       	ldi	r25, 0x00	; 0
  48:	63 ea       	ldi	r22, 0xA3	; 163
  4a:	0e 94 00 00 	call	0	; 0x0 <main>
        stepperInit();
  4e:	0e 94 00 00 	call	0	; 0x0 <main>
        sei();
  52:	78 94       	sei
        DDRC=0x6c;
  54:	8c e6       	ldi	r24, 0x6C	; 108
  56:	87 b9       	out	0x07, r24	; 7
	PORTC |= _BV(3);
  58:	43 9a       	sbi	0x08, 3	; 8
  5a:	20 ed       	ldi	r18, 0xD0	; 208
  5c:	37 e0       	ldi	r19, 0x07	; 7
  5e:	3b 83       	std	Y+3, r19	; 0x03
  60:	2a 83       	std	Y+2, r18	; 0x02
  62:	19 82       	std	Y+1, r1	; 0x01
  64:	77 24       	eor	r7, r7
  66:	88 24       	eor	r8, r8
  68:	99 24       	eor	r9, r9
					PORTC &= ~_BV(2);
					break;
                        }
                        if (data >= '4' && data <='9')
                        {
                            pause = (data - '0') * 300 + 10;
  6a:	6c e2       	ldi	r22, 0x2C	; 44
  6c:	26 2e       	mov	r2, r22
  6e:	61 e0       	ldi	r22, 0x01	; 1
  70:	36 2e       	mov	r3, r22
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  72:	58 ec       	ldi	r21, 0xC8	; 200
  74:	45 2e       	mov	r4, r21
  76:	51 2c       	mov	r5, r1
	unsigned advanceCount = 0;

        while (1)
        {

                u16 data = uart_get_buffered(); 
  78:	0e 94 00 00 	call	0	; 0x0 <main>
                if (0x0100 & data)
  7c:	90 ff       	sbrs	r25, 0
  7e:	00 c0       	rjmp	.+0      	; 0x80 <main+0x80>
                {
                        data &= 0xff;
  80:	8c 01       	movw	r16, r24
  82:	10 70       	andi	r17, 0x00	; 0
                        uart_send_char(data);
  84:	80 2f       	mov	r24, r16
  86:	0e 94 00 00 	call	0	; 0x0 <main>
                        switch (data)
  8a:	02 35       	cpi	r16, 0x52	; 82
  8c:	11 05       	cpc	r17, r1
  8e:	01 f4       	brne	.+0      	; 0x90 <main+0x90>
  90:	00 c0       	rjmp	.+0      	; 0x92 <main+0x92>
  92:	03 35       	cpi	r16, 0x53	; 83
  94:	11 05       	cpc	r17, r1
  96:	00 f4       	brcc	.+0      	; 0x98 <main+0x98>
  98:	06 34       	cpi	r16, 0x46	; 70
  9a:	11 05       	cpc	r17, r1
  9c:	01 f4       	brne	.+0      	; 0x9e <main+0x9e>
  9e:	00 c0       	rjmp	.+0      	; 0xa0 <main+0xa0>
  a0:	07 34       	cpi	r16, 0x47	; 71
  a2:	11 05       	cpc	r17, r1
  a4:	00 f4       	brcc	.+0      	; 0xa6 <main+0xa6>
  a6:	01 34       	cpi	r16, 0x41	; 65
  a8:	11 05       	cpc	r17, r1
  aa:	01 f0       	breq	.+0      	; 0xac <main+0xac>
  ac:	03 34       	cpi	r16, 0x43	; 67
  ae:	11 05       	cpc	r17, r1
  b0:	01 f4       	brne	.+0      	; 0xb2 <main+0xb2>
  b2:	00 c0       	rjmp	.+0      	; 0xb4 <main+0xb4>
  b4:	0f 33       	cpi	r16, 0x3F	; 63
  b6:	11 05       	cpc	r17, r1
  b8:	01 f0       	breq	.+0      	; 0xba <main+0xba>
  ba:	00 c0       	rjmp	.+0      	; 0xbc <main+0xbc>
  bc:	00 c0       	rjmp	.+0      	; 0xbe <main+0xbe>
  be:	0e 34       	cpi	r16, 0x4E	; 78
  c0:	11 05       	cpc	r17, r1
  c2:	01 f0       	breq	.+0      	; 0xc4 <main+0xc4>
  c4:	00 35       	cpi	r16, 0x50	; 80
  c6:	11 05       	cpc	r17, r1
  c8:	01 f0       	breq	.+0      	; 0xca <main+0xca>
  ca:	0c 34       	cpi	r16, 0x4C	; 76
  cc:	11 05       	cpc	r17, r1
  ce:	01 f0       	breq	.+0      	; 0xd0 <main+0xd0>
  d0:	00 c0       	rjmp	.+0      	; 0xd2 <main+0xd2>
  d2:	00 c0       	rjmp	.+0      	; 0xd4 <main+0xd4>
  d4:	0c 36       	cpi	r16, 0x6C	; 108
  d6:	11 05       	cpc	r17, r1
  d8:	01 f4       	brne	.+0      	; 0xda <main+0xda>
  da:	00 c0       	rjmp	.+0      	; 0xdc <main+0xdc>
  dc:	0d 36       	cpi	r16, 0x6D	; 109
  de:	11 05       	cpc	r17, r1
  e0:	00 f4       	brcc	.+0      	; 0xe2 <main+0xe2>
  e2:	03 36       	cpi	r16, 0x63	; 99
  e4:	11 05       	cpc	r17, r1
  e6:	01 f0       	breq	.+0      	; 0xe8 <main+0xe8>
  e8:	06 36       	cpi	r16, 0x66	; 102
  ea:	11 05       	cpc	r17, r1
  ec:	01 f0       	breq	.+0      	; 0xee <main+0xee>
  ee:	01 36       	cpi	r16, 0x61	; 97
  f0:	11 05       	cpc	r17, r1
  f2:	01 f4       	brne	.+0      	; 0xf4 <main+0xf4>
  f4:	00 c0       	rjmp	.+0      	; 0xf6 <main+0xf6>
  f6:	00 37       	cpi	r16, 0x70	; 112
  f8:	11 05       	cpc	r17, r1
  fa:	01 f0       	breq	.+0      	; 0xfc <main+0xfc>
  fc:	02 37       	cpi	r16, 0x72	; 114
  fe:	11 05       	cpc	r17, r1
 100:	01 f0       	breq	.+0      	; 0x102 <main+0x102>
 102:	0e 36       	cpi	r16, 0x6E	; 110
 104:	11 05       	cpc	r17, r1
 106:	01 f4       	brne	.+0      	; 0x108 <main+0x108>
 108:	00 c0       	rjmp	.+0      	; 0x10a <main+0x10a>
 10a:	33 e0       	ldi	r19, 0x03	; 3
 10c:	39 83       	std	Y+1, r19	; 0x01
 10e:	41 e0       	ldi	r20, 0x01	; 1
 110:	84 2e       	mov	r8, r20
 112:	91 2c       	mov	r9, r1
 114:	00 c0       	rjmp	.+0      	; 0x116 <main+0x116>
                        {
				case '?':
					uart_send_sync(helpMsg, sizeof(helpMsg));
 116:	80 e0       	ldi	r24, 0x00	; 0
 118:	90 e0       	ldi	r25, 0x00	; 0
 11a:	63 ea       	ldi	r22, 0xA3	; 163
 11c:	0e 94 00 00 	call	0	; 0x0 <main>
 120:	00 c0       	rjmp	.+0      	; 0x122 <main+0x122>
					break;
 122:	82 e0       	ldi	r24, 0x02	; 2
 124:	89 83       	std	Y+1, r24	; 0x01
 126:	00 c0       	rjmp	.+0      	; 0x128 <main+0x128>
					break;

                                case 'f':
                                case 'F':
                                        direction = FORWARD;
                                        break;
 128:	91 e0       	ldi	r25, 0x01	; 1
 12a:	99 83       	std	Y+1, r25	; 0x01
 12c:	00 c0       	rjmp	.+0      	; 0x12e <main+0x12e>

                                case 'r':
                                case 'R':
                                        direction = BACK;
                                        break;
 12e:	e3 e0       	ldi	r30, 0x03	; 3
 130:	e9 83       	std	Y+1, r30	; 0x01
 132:	00 c0       	rjmp	.+0      	; 0x134 <main+0x134>
				case 'N':
				case 'n':
					direction = NEXT;
					advanceCount = 3;
					break;
 134:	f4 e0       	ldi	r31, 0x04	; 4
 136:	f9 83       	std	Y+1, r31	; 0x01
 138:	33 e0       	ldi	r19, 0x03	; 3
 13a:	83 2e       	mov	r8, r19
 13c:	91 2c       	mov	r9, r1
 13e:	00 c0       	rjmp	.+0      	; 0x140 <main+0x140>
					break;

				case 'C':
				case 'c':
					// cameraOff
					PORTC &= ~_BV(3);
 140:	43 98       	cbi	0x08, 3	; 8
 142:	88 ee       	ldi	r24, 0xE8	; 232
 144:	93 e0       	ldi	r25, 0x03	; 3
 146:	f2 01       	movw	r30, r4
 148:	31 97       	sbiw	r30, 0x01	; 1
 14a:	01 f4       	brne	.+0      	; 0x14c <main+0x14c>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 14c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 14e:	01 f4       	brne	.+0      	; 0x150 <main+0x150>
					_delay_ms(100);
					// cameraOn
					PORTC |= _BV(3);
 150:	43 9a       	sbi	0x08, 3	; 8
 152:	00 c0       	rjmp	.+0      	; 0x154 <main+0x154>
					break;

				case 'l':
					// lampOn
					PORTC |= _BV(2);
 154:	42 9a       	sbi	0x08, 2	; 8
 156:	00 c0       	rjmp	.+0      	; 0x158 <main+0x158>
					break;

				case 'L':
					// lampOff
					PORTC &= ~_BV(2);
 158:	42 98       	cbi	0x08, 2	; 8
					break;
                        }
                        if (data >= '4' && data <='9')
 15a:	c8 01       	movw	r24, r16
 15c:	c4 97       	sbiw	r24, 0x34	; 52
 15e:	06 97       	sbiw	r24, 0x06	; 6
 160:	00 f4       	brcc	.+0      	; 0x162 <main+0x162>
                        {
                            pause = (data - '0') * 300 + 10;
 162:	02 9d       	mul	r16, r2
 164:	90 01       	movw	r18, r0
 166:	03 9d       	mul	r16, r3
 168:	30 0d       	add	r19, r0
 16a:	12 9d       	mul	r17, r2
 16c:	30 0d       	add	r19, r0
 16e:	11 24       	eor	r1, r1
 170:	26 53       	subi	r18, 0x36	; 54
 172:	38 43       	sbci	r19, 0x38	; 56
 174:	3b 83       	std	Y+3, r19	; 0x03
 176:	2a 83       	std	Y+2, r18	; 0x02
                        }
			switch (data)
 178:	01 33       	cpi	r16, 0x31	; 49
 17a:	11 05       	cpc	r17, r1
 17c:	01 f0       	breq	.+0      	; 0x17e <main+0x17e>
 17e:	02 33       	cpi	r16, 0x32	; 50
 180:	11 05       	cpc	r17, r1
 182:	00 f4       	brcc	.+0      	; 0x184 <main+0x184>
 184:	00 33       	cpi	r16, 0x30	; 48
 186:	11 05       	cpc	r17, r1
 188:	01 f4       	brne	.+0      	; 0x18a <main+0x18a>
 18a:	00 c0       	rjmp	.+0      	; 0x18c <main+0x18c>
 18c:	02 33       	cpi	r16, 0x32	; 50
 18e:	11 05       	cpc	r17, r1
 190:	01 f0       	breq	.+0      	; 0x192 <main+0x192>
 192:	03 33       	cpi	r16, 0x33	; 51
 194:	11 05       	cpc	r17, r1
 196:	01 f4       	brne	.+0      	; 0x198 <main+0x198>
 198:	86 eb       	ldi	r24, 0xB6	; 182
 19a:	93 e0       	ldi	r25, 0x03	; 3
 19c:	9b 83       	std	Y+3, r25	; 0x03
 19e:	8a 83       	std	Y+2, r24	; 0x02
 1a0:	00 c0       	rjmp	.+0      	; 0x1a2 <main+0x1a2>
 1a2:	ec e4       	ldi	r30, 0x4C	; 76
 1a4:	f4 e0       	ldi	r31, 0x04	; 4
 1a6:	fb 83       	std	Y+3, r31	; 0x03
 1a8:	ea 83       	std	Y+2, r30	; 0x02
 1aa:	00 c0       	rjmp	.+0      	; 0x1ac <main+0x1ac>
			{
				case '3': pause = 950; break;
				case '2': pause = 1100; break;
 1ac:	28 ee       	ldi	r18, 0xE8	; 232
 1ae:	33 e0       	ldi	r19, 0x03	; 3
 1b0:	3b 83       	std	Y+3, r19	; 0x03
 1b2:	2a 83       	std	Y+2, r18	; 0x02
 1b4:	00 c0       	rjmp	.+0      	; 0x1b6 <main+0x1b6>
				case '1': pause = 1000; break;
				case '0':
					direction = STOP;
					stepperInit();
 1b6:	0e 94 00 00 	call	0	; 0x0 <main>
 1ba:	19 82       	std	Y+1, r1	; 0x01
					break;
			}
                }
                if (direction == FORWARD || direction == NEXT)
 1bc:	89 81       	ldd	r24, Y+1	; 0x01
 1be:	82 50       	subi	r24, 0x02	; 2
 1c0:	82 30       	cpi	r24, 0x02	; 2
 1c2:	00 f4       	brcc	.+0      	; 0x1c4 <main+0x1c4>
		{
                    stepper1Forward();
 1c4:	0e 94 00 00 	call	0	; 0x0 <main>
 1c8:	00 c0       	rjmp	.+0      	; 0x1ca <main+0x1ca>
		}
                else if (direction == BACK || direction == PREVIOUS)
 1ca:	39 81       	ldd	r19, Y+1	; 0x01
 1cc:	31 30       	cpi	r19, 0x01	; 1
 1ce:	01 f0       	breq	.+0      	; 0x1d0 <main+0x1d0>
 1d0:	34 30       	cpi	r19, 0x04	; 4
 1d2:	01 f4       	brne	.+0      	; 0x1d4 <main+0x1d4>
		{
                    stepper1Back();
 1d4:	0e 94 00 00 	call	0	; 0x0 <main>
		}

		irData <<= 1;
		irData |= (PINC & _BV(1)) >> 1;
 1d8:	86 b1       	in	r24, 0x06	; 6
 1da:	77 0c       	add	r7, r7
 1dc:	90 e0       	ldi	r25, 0x00	; 0
 1de:	82 70       	andi	r24, 0x02	; 2
 1e0:	90 70       	andi	r25, 0x00	; 0
 1e2:	95 95       	asr	r25
 1e4:	87 95       	ror	r24
 1e6:	78 2a       	or	r7, r24
		if (0xf0 == irData && direction == NEXT || direction == PREVIOUS)
 1e8:	80 ef       	ldi	r24, 0xF0	; 240
 1ea:	78 16       	cp	r7, r24
 1ec:	01 f4       	brne	.+0      	; 0x1ee <main+0x1ee>
 1ee:	99 81       	ldd	r25, Y+1	; 0x01
 1f0:	93 30       	cpi	r25, 0x03	; 3
 1f2:	01 f0       	breq	.+0      	; 0x1f4 <main+0x1f4>
 1f4:	e9 81       	ldd	r30, Y+1	; 0x01
 1f6:	e4 30       	cpi	r30, 0x04	; 4
 1f8:	01 f4       	brne	.+0      	; 0x1fa <main+0x1fa>
		{
			if (--advanceCount <= 0)
 1fa:	08 94       	sec
 1fc:	81 08       	sbc	r8, r1
 1fe:	91 08       	sbc	r9, r1
 200:	81 14       	cp	r8, r1
 202:	91 04       	cpc	r9, r1
 204:	01 f4       	brne	.+0      	; 0x206 <main+0x206>
			{
				direction = STOP;
				stepperInit();
 206:	0e 94 00 00 	call	0	; 0x0 <main>
 20a:	19 82       	std	Y+1, r1	; 0x01
 20c:	77 24       	eor	r7, r7
				irData = 0;
			}
		}
                _delay_us(pause);
 20e:	2a 81       	ldd	r18, Y+2	; 0x02
 210:	3b 81       	ldd	r19, Y+3	; 0x03
 212:	b9 01       	movw	r22, r18
 214:	88 27       	eor	r24, r24
 216:	77 fd       	sbrc	r23, 7
 218:	80 95       	com	r24
 21a:	98 2f       	mov	r25, r24
 21c:	0e 94 00 00 	call	0	; 0x0 <main>
 220:	5b 01       	movw	r10, r22
 222:	6c 01       	movw	r12, r24
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
 224:	2b ea       	ldi	r18, 0xAB	; 171
 226:	3a ea       	ldi	r19, 0xAA	; 170
 228:	4a e2       	ldi	r20, 0x2A	; 42
 22a:	50 e4       	ldi	r21, 0x40	; 64
 22c:	0e 94 00 00 	call	0	; 0x0 <main>
 230:	7b 01       	movw	r14, r22
 232:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
 234:	20 e0       	ldi	r18, 0x00	; 0
 236:	30 e0       	ldi	r19, 0x00	; 0
 238:	40 e8       	ldi	r20, 0x80	; 128
 23a:	5f e3       	ldi	r21, 0x3F	; 63
 23c:	0e 94 00 00 	call	0	; 0x0 <main>
 240:	88 23       	and	r24, r24
 242:	04 f4       	brge	.+0      	; 0x244 <main+0x244>
 244:	61 e0       	ldi	r22, 0x01	; 1
 246:	00 c0       	rjmp	.+0      	; 0x248 <main+0x248>
		__ticks = 1;
	else if (__tmp > 255)
 248:	c8 01       	movw	r24, r16
 24a:	b7 01       	movw	r22, r14
 24c:	20 e0       	ldi	r18, 0x00	; 0
 24e:	30 e0       	ldi	r19, 0x00	; 0
 250:	4f e7       	ldi	r20, 0x7F	; 127
 252:	53 e4       	ldi	r21, 0x43	; 67
 254:	0e 94 00 00 	call	0	; 0x0 <main>
 258:	18 16       	cp	r1, r24
 25a:	04 f0       	brlt	.+0      	; 0x25c <main+0x25c>
 25c:	00 c0       	rjmp	.+0      	; 0x25e <main+0x25e>
	{
		_delay_ms(__us / 1000.0);
 25e:	c6 01       	movw	r24, r12
 260:	b5 01       	movw	r22, r10
 262:	20 e0       	ldi	r18, 0x00	; 0
 264:	30 e0       	ldi	r19, 0x00	; 0
 266:	4a e7       	ldi	r20, 0x7A	; 122
 268:	54 e4       	ldi	r21, 0x44	; 68
 26a:	0e 94 00 00 	call	0	; 0x0 <main>
 26e:	5b 01       	movw	r10, r22
 270:	6c 01       	movw	r12, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
 272:	20 e0       	ldi	r18, 0x00	; 0
 274:	30 e0       	ldi	r19, 0x00	; 0
 276:	4a ef       	ldi	r20, 0xFA	; 250
 278:	54 e4       	ldi	r21, 0x44	; 68
 27a:	0e 94 00 00 	call	0	; 0x0 <main>
 27e:	7b 01       	movw	r14, r22
 280:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
 282:	20 e0       	ldi	r18, 0x00	; 0
 284:	30 e0       	ldi	r19, 0x00	; 0
 286:	40 e8       	ldi	r20, 0x80	; 128
 288:	5f e3       	ldi	r21, 0x3F	; 63
 28a:	0e 94 00 00 	call	0	; 0x0 <main>
 28e:	88 23       	and	r24, r24
 290:	04 f4       	brge	.+0      	; 0x292 <main+0x292>
 292:	61 e0       	ldi	r22, 0x01	; 1
 294:	70 e0       	ldi	r23, 0x00	; 0
 296:	00 c0       	rjmp	.+0      	; 0x298 <main+0x298>
		__ticks = 1;
	else if (__tmp > 65535)
 298:	c8 01       	movw	r24, r16
 29a:	b7 01       	movw	r22, r14
 29c:	20 e0       	ldi	r18, 0x00	; 0
 29e:	3f ef       	ldi	r19, 0xFF	; 255
 2a0:	4f e7       	ldi	r20, 0x7F	; 127
 2a2:	57 e4       	ldi	r21, 0x47	; 71
 2a4:	0e 94 00 00 	call	0	; 0x0 <main>
 2a8:	18 16       	cp	r1, r24
 2aa:	04 f4       	brge	.+0      	; 0x2ac <main+0x2ac>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
 2ac:	c6 01       	movw	r24, r12
 2ae:	b5 01       	movw	r22, r10
 2b0:	20 e0       	ldi	r18, 0x00	; 0
 2b2:	30 e0       	ldi	r19, 0x00	; 0
 2b4:	40 e2       	ldi	r20, 0x20	; 32
 2b6:	51 e4       	ldi	r21, 0x41	; 65
 2b8:	0e 94 00 00 	call	0	; 0x0 <main>
 2bc:	0e 94 00 00 	call	0	; 0x0 <main>
 2c0:	00 c0       	rjmp	.+0      	; 0x2c2 <main+0x2c2>
 2c2:	c2 01       	movw	r24, r4
 2c4:	01 97       	sbiw	r24, 0x01	; 1
 2c6:	01 f4       	brne	.+0      	; 0x2c8 <main+0x2c8>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 2c8:	61 50       	subi	r22, 0x01	; 1
 2ca:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 2cc:	61 15       	cp	r22, r1
 2ce:	71 05       	cpc	r23, r1
 2d0:	01 f4       	brne	.+0      	; 0x2d2 <main+0x2d2>
 2d2:	00 c0       	rjmp	.+0      	; 0x2d4 <main+0x2d4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
 2d4:	c8 01       	movw	r24, r16
 2d6:	b7 01       	movw	r22, r14
 2d8:	0e 94 00 00 	call	0	; 0x0 <main>
 2dc:	cb 01       	movw	r24, r22
 2de:	01 97       	sbiw	r24, 0x01	; 1
 2e0:	01 f4       	brne	.+0      	; 0x2e2 <main+0x2e2>
 2e2:	00 c0       	rjmp	.+0      	; 0x2e4 <main+0x2e4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
 2e4:	c8 01       	movw	r24, r16
 2e6:	b7 01       	movw	r22, r14
 2e8:	0e 94 00 00 	call	0	; 0x0 <main>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 2ec:	6a 95       	dec	r22
 2ee:	01 f4       	brne	.+0      	; 0x2f0 <main+0x2f0>
 2f0:	00 c0       	rjmp	.+0      	; 0x2f2 <__SREG__+0x2b3>
