
stepper.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000b4  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000e8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000002  00000000  00000000  000000e8  2**0
                  ALLOC
  3 .stab         000007bc  00000000  00000000  000000e8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000a3c  00000000  00000000  000008a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .progmem.data 00000006  00000000  00000000  000012e0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
Disassembly of section .text:

00000000 <stepperInit>:

static char * stepPtr;

void stepperInit(void)
{
        DDRF = 0x1e; // PF1,2,3,4
   0:	8e e1       	ldi	r24, 0x1E	; 30
   2:	80 bb       	out	0x10, r24	; 16
        PORTF &= ~0x1e; // set all bits low
   4:	81 b3       	in	r24, 0x11	; 17
   6:	81 7e       	andi	r24, 0xE1	; 225
   8:	81 bb       	out	0x11, r24	; 17
        stepPtr = stepSequence;
   a:	80 e0       	ldi	r24, 0x00	; 0
   c:	90 e0       	ldi	r25, 0x00	; 0
   e:	90 93 00 00 	sts	0x0000, r25
  12:	80 93 00 00 	sts	0x0000, r24
}
  16:	08 95       	ret

00000018 <stepper1Forward>:

void stepper1Forward(void)
{
        unsigned char data = pgm_read_byte_near(stepPtr);
  18:	e0 91 00 00 	lds	r30, 0x0000
  1c:	f0 91 00 00 	lds	r31, 0x0000
  20:	84 91       	lpm	r24, Z+
        if (0 == data)
  22:	88 23       	and	r24, r24
  24:	01 f0       	breq	.+0      	; 0x26 <stepper1Forward+0xe>
  26:	28 2f       	mov	r18, r24
  28:	00 c0       	rjmp	.+0      	; 0x2a <stepper1Forward+0x12>
        {
                stepPtr = stepSequence + 1;
  2a:	e0 e0       	ldi	r30, 0x00	; 0
  2c:	f0 e0       	ldi	r31, 0x00	; 0
  2e:	f0 93 00 00 	sts	0x0000, r31
  32:	e0 93 00 00 	sts	0x0000, r30
                 data = pgm_read_byte_near(stepPtr);
  36:	24 91       	lpm	r18, Z+
        }
        stepPtr++;
  38:	80 91 00 00 	lds	r24, 0x0000
  3c:	90 91 00 00 	lds	r25, 0x0000
  40:	01 96       	adiw	r24, 0x01	; 1
  42:	90 93 00 00 	sts	0x0000, r25
  46:	80 93 00 00 	sts	0x0000, r24
        PORTF = data;
  4a:	21 bb       	out	0x11, r18	; 17
}
  4c:	08 95       	ret

0000004e <stepper1Back>:

void stepper1Back(void)
{
        unsigned char data = pgm_read_byte_near(stepPtr);
  4e:	e0 91 00 00 	lds	r30, 0x0000
  52:	f0 91 00 00 	lds	r31, 0x0000
  56:	84 91       	lpm	r24, Z+
        if (0 == data)
  58:	88 23       	and	r24, r24
  5a:	01 f0       	breq	.+0      	; 0x5c <stepper1Back+0xe>
  5c:	28 2f       	mov	r18, r24
  5e:	00 c0       	rjmp	.+0      	; 0x60 <stepper1Back+0x12>
        {
                stepPtr = stepSequence + 4;
  60:	e0 e0       	ldi	r30, 0x00	; 0
  62:	f0 e0       	ldi	r31, 0x00	; 0
  64:	f0 93 00 00 	sts	0x0000, r31
  68:	e0 93 00 00 	sts	0x0000, r30
                data = pgm_read_byte_near(stepPtr);
  6c:	24 91       	lpm	r18, Z+
        }
        stepPtr--;
  6e:	80 91 00 00 	lds	r24, 0x0000
  72:	90 91 00 00 	lds	r25, 0x0000
  76:	01 97       	sbiw	r24, 0x01	; 1
  78:	90 93 00 00 	sts	0x0000, r25
  7c:	80 93 00 00 	sts	0x0000, r24
        PORTF = data;
  80:	21 bb       	out	0x11, r18	; 17
}
  82:	08 95       	ret

00000084 <stepper1Stop>:

static char * stepPtr;

void stepperInit(void)
{
        DDRF = 0x1e; // PF1,2,3,4
  84:	8e e1       	ldi	r24, 0x1E	; 30
  86:	80 bb       	out	0x10, r24	; 16
        PORTF &= ~0x1e; // set all bits low
  88:	81 b3       	in	r24, 0x11	; 17
  8a:	81 7e       	andi	r24, 0xE1	; 225
  8c:	81 bb       	out	0x11, r24	; 17
        stepPtr = stepSequence;
  8e:	80 e0       	ldi	r24, 0x00	; 0
  90:	90 e0       	ldi	r25, 0x00	; 0
  92:	90 93 00 00 	sts	0x0000, r25
  96:	80 93 00 00 	sts	0x0000, r24
}

void stepper1Stop(void)
{
 	stepperInit();
}
  9a:	08 95       	ret

0000009c <coilAForward>:

void coilAForward(void)
{
	COILA_PLUS_ON;
  9c:	8c 9a       	sbi	0x11, 4	; 17
	COILA_MINUS_OFF;
  9e:	8b 98       	cbi	0x11, 3	; 17
}
  a0:	08 95       	ret

000000a2 <coilABackward>:

void coilABackward(void)
{
	COILA_PLUS_OFF;
  a2:	8c 98       	cbi	0x11, 4	; 17
	COILA_MINUS_ON;
  a4:	8b 9a       	sbi	0x11, 3	; 17
}
  a6:	08 95       	ret

000000a8 <coilBForward>:

void coilBForward(void)
{
	COILB_PLUS_ON;
  a8:	8a 9a       	sbi	0x11, 2	; 17
	COILB_MINUS_OFF;
  aa:	89 98       	cbi	0x11, 1	; 17
}
  ac:	08 95       	ret

000000ae <coilBBackward>:

void coilBBackward(void)
{
	COILB_PLUS_OFF;
  ae:	8a 98       	cbi	0x11, 2	; 17
	COILB_MINUS_ON;
  b0:	89 9a       	sbi	0x11, 1	; 17
}
  b2:	08 95       	ret
